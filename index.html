<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Componente – Tarjetas de vocabulario</title>
  <link rel="stylesheet" href="component-styles.css" />

  <style>
    /* Header estilo juego de categorización */
    header {
      grid-area: head;
      padding: 14px 18px 10px;
      border-bottom: 1px solid #e5e7eb;
      text-align: center;
    }

    p.intro {
      display: none;
    }

    /* Content Grid */
    .content {
      grid-area: content;
      padding: 0 18px 16px;
      height: 100%;
      display: grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 22px;
    }

    /* Card Styles */
    .stage {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      padding: 8px 0 0;
    }

    .card {
      width: 400px;
      height: 320px;
      perspective: 1000px;
      position: relative;
      cursor: pointer;
    }

    .card .face {
      position: absolute;
      inset: 0;
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow-frame);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      backface-visibility: hidden;
      transition: transform .5s ease, box-shadow .2s ease;
      text-align: center;
    }

    .face img {
      max-width: 100%;
      max-height: 100%;
      object-fit: cover;
    }

    /* Front matches h2 style */
    .card .front {
      font-size: 24px;
      font-weight: 700;
      color: var(--accent);
      line-height: 1.25;
    }

    /* Back matches body style */
    .card .back {
      transform: rotateY(180deg);
      font-size: 16px;
      color: var(--muted);
      line-height: 1.4;
    }

    .card.flip .front {
      transform: rotateY(180deg);
    }

    .card.flip .back {
      transform: rotateY(360deg);
    }

    /* Buttons */
    .actions {
      margin-top: 12px;
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .btn {
      font-size: 14px;
      font-weight: 600;
      color: #fff !important;
      background: var(--accent);
      border: 0px;
      border-radius: 18px;
      padding: 10px 16px;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .btn:hover {
      opacity: 0.9;
    }

    /* Sidebar / Panel */
    .side {
      background: #eeeeee;
      border-radius: 6px;
      padding: 14px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .stat {
      background: #fff;
      padding: 12px;
      border-radius: 6px;
      border: 1px solid #e1e1e1;
    }

    .stat h3 {
      margin: 0 0 6px;
      font-size: 18px;
    }

    .stat p {
      margin: 0;
    }

    .list {
      flex: 1 1 auto;
      overflow: auto;
      margin-top: 8px;
    }

    .chip {
      display: inline-block;
      margin: 4px;
      padding: 4px 8px;
      border-radius: 4px;
      background: rgba(91, 0, 255, 0.08);
      color: var(--accent);
      font-size: 12px;
      font-weight: 600;
    }

    /* Barra de progreso oculta */
    .progress {
      display: none;
    }

    .progress .bar {
      width: 0;
    }

    /* Animations */
    .anim-correct {
      animation: pop .35s ease;
    }

    .anim-again {
      animation: shake .35s ease;
    }

    @keyframes pop {
      0% {
        transform: scale(1);
      }

      60% {
        transform: scale(1.06);
      }

      100% {
        transform: scale(1);
      }
    }

    @keyframes shake {

      10%,
      90% {
        transform: translateX(-1px);
      }

      20%,
      80% {
        transform: translateX(2px);
      }

      30%,
      50%,
      70% {
        transform: translateX(-4px);
      }

      40%,
      60% {
        transform: translateX(4px);
      }
    }

    /* Responsive similar al classification + ajuste flashcards */

    /* Breakpoint extra móvil */
    @media screen and (max-width: 700px) {

      .frame {
        overflow: hidden !important;
        display: flex !important;
        flex-direction: column !important;
      }

      .inner-card {
        display: flex !important;
        flex-direction: column !important;
        overflow: hidden !important;
      }

      .comp-wrap {
        grid-template-rows: auto 1fr;
      }

      .content {
        grid-template-columns: 1fr;
        gap: 10px;
        padding: 0 10px 10px;
      }

      .card {
        width: 100%;
        height: 260px;
      }

      .actions {
        margin-top: 8px;
      }

      .side {
        background: none;
        padding: 0;
        align-items: center;
        text-align: center;
      }

      .stat {
        border: none;
        overflow: hidden;
      }
    }
  </style>

  <script>
    /* Script de modo embebido tomado de component_clasification */
    (function () {
      function setEmbedded() {
        document.documentElement.classList.add('embedded-mode');
        if (document.body) document.body.classList.add('embedded-mode');
      }

      try {
        if (window.self !== window.top || window.parent !== window) {
          setEmbedded();
        }
      } catch (e) {
        setEmbedded();
      }

      window.addEventListener('DOMContentLoaded', function () {
        try {
          if (window.self !== window.top || window.parent !== window) {
            setEmbedded();
          }
        } catch (e) {
          setEmbedded();
        }
      });
    })();
  </script>
</head>

<body>
  <div class="app-root">
    <div class="frame">
      <div class="inner-card">
        <!-- Mantengo el wrapper original con data-component-id -->
        <section class="comp-wrap" data-component-id="flash-001">
          <header>
            <h1 class="template">Tarjetas de vocabulario</h1>
            <h2>Toca para voltear. Marca “Lo sé” o “Repasar”.</h2>
            <p class="intro">Juego de tarjetas educativas para aprender vocabulario con animaciones y seguimiento del
              progreso.</p>
          </header>

          <div class="content">
            <div class="stage">
              <div class="card" id="card" aria-live="polite" tabindex="0">
                <div class="face front" id="front">
                  <img id="frontImg" src="" alt="" style="display:none;">
                  <span id="frontText"></span>
                </div>
                <div class="face back" id="back">
                  <img id="backImg" src="" alt="" style="display:none;">
                  <span id="backText"></span>
                </div>
              </div>
              <div class="actions">
                <button class="btn flip" id="flip">Voltear</button>
                <button class="btn again" id="again">Repasar</button>
                <button class="btn good" id="good">Lo sé</button>
              </div>
            </div>

            <aside class="side">
              <div class="stat">
                <h3>Progreso</h3>
                <p><strong id="mastered">0</strong> dominadas de <strong id="total">0</strong> (<span
                    id="pct">0</span>%)</p>
              </div>
              <div class="stat">
                <h3>Siguientes en cola</h3>
                <div class="list" id="queue"></div>
              </div>
            </aside>
          </div>

          <!-- Barra de progreso oculta manteniendo la estructura para el script -->
          <div class="progress" aria-hidden="true">
            <div class="bar" id="bar"></div>
          </div>
        </section>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const wrap = document.querySelector('.comp-wrap');
      const id = wrap.getAttribute('data-component-id') || 'flashcards-component';

      // ======= DECK por defecto (igual que el original) =======
      let deck = [
        {
          term: '¿Qué es Flamming?',
          def: 'Un tipo de ciberacoso que consiste en insultos en foros públicos, que a veces se infiltran incluso en tareas escolares.'
        },
        { term: "apple", imgFront: "https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/Playing_card_spade_A.svg/1638px-Playing_card_spade_A.svg.png", def: "manzana" },
        { term: "Homer is hiding", imgBack: "https://educa3-0.b-cdn.net/wp-content/uploads/2019/06/homer.gif", def: "bananafasdas" },
        {
          term: '¿Qué es Outing?',
          def: 'Un tipo de ciberacoso que consiste en revelar información privada de alguien sin su consentimiento.'
        },

        {
          term: '¿Qué es Phishing?',
          def: 'Un tipo de ciberataque que consiste en suplantar la identidad para robar datos.'
        },

        {
          term: '¿Qué es el ransomware en instituciones educativas?',
          def: 'Un ciberataque que secuestra los datos de la institución y exige un rescate para liberarlos.'
        },

        {
          term: '¿Qué son los neuroderechos?',
          def: 'Un concepto legal y ético, debatido en países como Chile, que busca proteger la actividad cerebral y la integridad mental frente a las tecnologías.'
        },

        {
          term: '¿Qué es un dato personal?',
          def: 'Cualquier dato sobre una persona identificada o identificable, como nombre, DNI, email, foto o ubicación.'
        },

        {
          term: '¿Qué es la discriminación algorítmica?',
          def: 'Decisiones injustas o perjudiciales tomadas por una IA debido a sesgos en datos de entrenamiento o en su algoritmo.'
        },

        {
          term: '¿Cuál es la paradoja de Moravec?',
          def: 'La IA es muy buena en tareas difíciles para humanos (cálculo, patrones), pero muy torpe en cosas obvias (sentido común, contexto).'
        },

        {
          term: '¿Qué es la supresión en anonimización?',
          def: 'Técnica que elimina filas o columnas completas de un conjunto de datos para proteger identidades.'
        },

        {
          term: '¿Qué es el enmascaramiento en anonimización?',
          def: 'Técnica que tapa u oculta parte de un dato, como los últimos dígitos de un número telefónico.'
        },

        {
          term: '¿Qué es la K-anonimidad?',
          def: "Una técnica de anonimización compleja que busca modificar un conjunto de datos para que cada individuo sea indistinguible de al menos 'k-1' otros individuos dentro del mismo conjunto de datos."
        }
      ];

      // Estado
      let index = 0;                   // índice en la cola actual
      let mastered = new Set();        // ids dominados
      let queue = deck.map((d, i) => i); // cola de índices
      let flipped = false;

      // UI refs
      const card = document.getElementById('card');
      const front = document.getElementById('front');
      const back = document.getElementById('back');
      const flipBtn = document.getElementById('flip');
      const goodBtn = document.getElementById('good');
      const againBtn = document.getElementById('again');
      const qDiv = document.getElementById('queue');
      const masteredEl = document.getElementById('mastered');
      const totalEl = document.getElementById('total');
      const pctEl = document.getElementById('pct');
      const bar = document.getElementById('bar');
      const frontImg = document.getElementById('frontImg');
      const frontText = document.getElementById('frontText');
      const backImg = document.getElementById('backImg');
      const backText = document.getElementById('backText');

      function post(pct) {
        try {
          window.parent && window.parent.postMessage({
            type: 'componentProgress',
            componentId: id,
            progress: pct,
            completed: pct >= 95,
            stats: { mastered: mastered.size, total: deck.length }
          }, '*');
        } catch (e) { }
      }

      function render() {
        if (queue.length === 0) {
          frontText.textContent = '¡Completado!';
          frontImg.style.display = "none";
          backText.textContent = 'Has dominado todas las tarjetas.';
          backImg.style.display = "none";
          card.classList.add('flip'); // mostrar mensaje final en el reverso
          flipBtn.disabled = true; againBtn.disabled = true; goodBtn.disabled = true;
          updateStats();
          return;
        }
        const cur = deck[queue[index]];
        // FRONT side
        if (cur.imgFront) {
          frontImg.src = cur.imgFront;
          frontImg.style.display = "block";
          frontText.style.display = "none";
        } else {
          frontText.textContent = cur.term;
          frontImg.style.display = "none";
          frontText.style.display = "block";
        }

        // BACK side
        if (cur.imgBack) {
          backImg.src = cur.imgBack;
          backImg.style.display = "block";
          backText.style.display = "none";
        } else {
          backText.textContent = cur.def;
          backImg.style.display = "none";
          backText.style.display = "block";
        }

        card.classList.toggle('flip', flipped);
        // queue preview
        qDiv.innerHTML = queue.slice(index, index + 6).map(i => '<span class="chip">' + deck[i].term + '</span>').join('');
        updateStats();
      }

      function updateStats() {
        const pct = Math.round((mastered.size / deck.length) * 100);
        masteredEl.textContent = mastered.size;
        totalEl.textContent = deck.length;
        pctEl.textContent = pct;
        if (bar) {
          bar.style.width = pct + '%';
        }
        post(pct);
      }

      function flip() { flipped = !flipped; card.classList.toggle('flip', flipped); }

      function nextCard(animClass) {
        card.classList.add(animClass);
        setTimeout(() => card.classList.remove(animClass), 380);

        flipped = false;
        index = (index + 1) % queue.length;
        render();
      }

      goodBtn.addEventListener('click', () => {
        const curId = queue[index];
        mastered.add(curId);
        queue.splice(index, 1);
        if (queue.length === 0) { render(); return; }
        if (index >= queue.length) index = 0;
        nextCard('anim-correct');
      });

      againBtn.addEventListener('click', () => {
        const curId = queue[index];
        if (queue.length > 1) {
          queue.push(curId);
          queue.splice(index, 1);
          if (index >= queue.length) index = 0;
        }
        nextCard('anim-again');
      });

      flipBtn.addEventListener('click', flip);
      card.addEventListener('click', flip);
      card.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); flip(); } });

      // API pública para el orquestador
      window.Flashcards = {
        setDeck(arr) {
          if (!Array.isArray(arr) || !arr.length) return;
          deck = arr;
          index = 0;
          mastered = new Set();
          queue = deck.map((_, i) => i);
          flipped = false;
          render();
        },
        shuffle() {
          for (let i = queue.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));[queue[i], queue[j]] = [queue[j], queue[i]];
          }
          index = 0; render();
        }
      };
      // Inicial
      render();
    })();
  </script>
</body>
</html>